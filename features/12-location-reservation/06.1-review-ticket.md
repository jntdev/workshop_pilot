# 6.1 — Review : Implémentation du chargement limité

## Question 1 : Approche d'implémentation Laravel

### Requête proposée

```php
// Dans LocationController::index()

$startWindow = now()->subDays(15)->startOfDay();
$endWindow = now()->addDays(30)->endOfDay();

$reservations = Reservation::with(['client', 'items.bikeType', 'selection'])
    ->where('statut', '!=', 'annule')
    ->where(function ($query) use ($startWindow, $endWindow) {
        // Cas 1 : Réservations dans la fenêtre glissante
        $query->whereBetween('date_reservation', [$startWindow, $endWindow])
            // Cas 2 : Réservations démarrées avant mais toujours actives
            ->orWhere(function ($q) use ($startWindow) {
                $q->where('date_reservation', '<', $startWindow)
                  ->where('date_retour', '>=', now()->startOfDay());
            });
    })
    ->orderBy('date_reservation')
    ->get();
```

### Mapping existant

Le mapping actuel (client, items, selection) reste inchangé. Seule la clause `where` est ajoutée.

### Points d'attention

1. **Timezone** : Utiliser `startOfDay()` et `endOfDay()` pour éviter les problèmes de fuseaux horaires.
2. **Performance** : Ajouter un index composite sur `(statut, date_reservation, date_retour)` si les performances deviennent un problème.
3. **Tests** : Seeder des réservations aux bornes exactes pour valider les cas limites.

---

## Question 4 : UX pour navigation au-delà de J+30

### Problématique

Si l'utilisateur scroll au-delà de la fenêtre chargée (ex: vers avril alors qu'on est en février), il verra des cellules vides même si des réservations existent.

### Approche proposée : Lazy Loading par fenêtre

#### Option A — Chargement à la demande (recommandée)

1. **Détection du scroll** : Quand l'utilisateur scroll vers une zone non chargée, détecter la date visible.

2. **Indicateur visuel** : Afficher un bandeau "Chargement des réservations..." ou un bouton "Charger mars-avril".

3. **Endpoint API dédié** :
   ```php
   // Route: GET /api/reservations/window?start=2026-03-01&end=2026-04-15

   public function window(Request $request)
   {
       $start = Carbon::parse($request->start)->startOfDay();
       $end = Carbon::parse($request->end)->endOfDay();

       return Reservation::with(['client', 'items.bikeType', 'selection'])
           ->where('statut', '!=', 'annule')
           ->where(function ($q) use ($start, $end) {
               $q->whereBetween('date_reservation', [$start, $end])
                 ->orWhere(function ($q2) use ($start) {
                     $q2->where('date_reservation', '<', $start)
                        ->where('date_retour', '>=', $start);
                 });
           })
           ->get();
   }
   ```

4. **Fusion côté client** : Merger les nouvelles réservations dans le state React sans dupliquer.
   ```typescript
   const mergeReservations = (existing: LoadedReservation[], incoming: LoadedReservation[]) => {
       const map = new Map(existing.map(r => [r.id, r]));
       incoming.forEach(r => map.set(r.id, r));
       return Array.from(map.values());
   };
   ```

#### Option B — Navigation par mois (plus simple)

1. Ajouter des boutons "< Mois précédent" et "Mois suivant >" dans le header.
2. Chaque navigation recharge complètement les réservations pour la nouvelle fenêtre centrée sur ce mois.
3. Moins fluide mais plus simple à implémenter.

### Recommandation

Commencer par **Option B** (navigation par mois) pour la V1, puis évoluer vers **Option A** si le besoin de scroll fluide se confirme.

---

## Prochaines étapes

- [ ] Valider cette approche avec l'équipe
- [ ] Implémenter la requête Laravel (Question 1)
- [ ] Choisir Option A ou B pour la navigation (Question 4)
- [ ] Écrire les tests Feature pour valider les cas limites
