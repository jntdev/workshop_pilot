# 6.2 — Lazy loading des réservations (Option A)

Nous retenons le chargement à la demande pour couvrir les périodes au-delà de J+30 sans alourdir le payload initial.

## Objectif
Quand l’utilisateur scroll hors de la fenêtre pré-chargée (J−15 → J+30), déclencher automatiquement une requête pour charger les réservations manquantes (avant/au-delà), puis fusionner le résultat dans l’état local.

## Architecture retenue

### 1. API fenêtrée
- Route `GET /api/reservations/window?start=YYYY-MM-DD&end=YYYY-MM-DD`.
- Contrôleur :
  ```php
  public function window(Request $request)
  {
      $start = Carbon::parse($request->start)->startOfDay();
      $end = Carbon::parse($request->end)->endOfDay();

      return Reservation::with(['client', 'items.bikeType'])
          ->where('statut', '!=', 'annule')
          ->where(function ($q) use ($start, $end) {
              $q->whereBetween('date_reservation', [$start, $end])
                ->orWhere(function ($q2) use ($start) {
                    $q2->where('date_reservation', '<', $start)
                       ->where('date_retour', '>=', $start);
                });
          })
          ->orderBy('date_reservation')
          ->get()
          ->map(fn ($r) => ReservationResource::fromModel($r));
  }
  ```
- Réutiliser le même mapping que pour la page principale (client complet, items, sélection, couleur).

> **Note technique** : `selection` n'est pas une relation Eloquent mais un attribut JSON casté dans `Reservation::$casts`. Il ne doit **pas** être ajouté au `with()` (sinon erreur "Call to undefined relationship"). L'attribut est automatiquement inclus lors de la sérialisation du modèle via le cast.

### 2. Détection front
- `LocationIndex` calcule les dates visibles via la virtualisation (`rowVirtualizer`). Lorsqu’un utilisateur scroll à proximité d’une date hors fenêtre (ex. `day.date > loadedMaxDate`), on déclenche un `loadWindow(start, end)`.
- Pour éviter les spams :
  - conserver `loadedWindows: Array<{ start: string; end: string }>` pour ne pas recharger deux fois la même période ;
  - appliquer un debounce (200 ms) sur le handler de scroll.

### 3. Fusion des données
```ts
function mergeReservations(existing: LoadedReservation[], incoming: LoadedReservation[]) {
    const map = new Map(existing.map((r) => [r.id, r]));
    incoming.forEach((reservation) => map.set(reservation.id, reservation));
    return Array.from(map.values()).sort((a, b) => a.date_reservation.localeCompare(b.date_reservation));
}
```
- Après `fetch`, mettre à jour l’état `reservations` et reconstruire les index (cells, map par id).
- Le hook `useReservationDraft` n’a pas besoin de modification : il consomme simplement le nouvel état.

### 4. UX
- Afficher un spinner ou un bandeau discret “Chargement des réservations…” lorsque la requête est en cours.
- Si aucune réservation n’est renvoyée pour la fenêtre demandée, afficher un tag “Aucune réservation sur cette période” pour rassurer l’utilisateur.
- En cas d’erreur réseau, proposer un bouton “Réessayer”.

## Tests
- Tests Feature API pour `window()` : vérifier que les mêmes règles de date s’appliquent et que les données sérialisées correspondent au mapping principal.
- Tests front unitaires :
  - `mergeReservations` (pas de duplications, tri correct).
  - `shouldLoadWindow` (détection de fenêtres non chargées).
- Test E2E manuel : scroller jusqu’en avril alors qu’on est en février → le panneau se remplit après chargement.

## Évolutions possibles
- Ajouter un préchargement proactif : lorsqu’on approche de la fin d’une fenêtre, lancer la requête suivante en tâche de fond.
- Mutualiser les appels via un hook `useReservationLoader` (cache en mémoire + annulation si l’utilisateur remonte).
